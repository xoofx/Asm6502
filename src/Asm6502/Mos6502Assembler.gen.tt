<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var procs = new string[] { "Mos6502", "Mos6510" };
#>
// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.

using Asm6502.Expressions;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace Asm6502;
<# foreach(var proc in procs) { #>

/// <summary>
/// Represents a <#= proc.Substring(3) #> assembler for generating machine code and managing labels.
/// </summary>
public partial class <#= proc #>Assembler : <#= proc #>Assembler<<#= proc #>Assembler>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="<#= proc #>Assembler"/> class.
    /// </summary>
    /// <param name="baseAddress">The base address for code generation.</param>
    public  <#= proc #>Assembler(ushort baseAddress = 0xC000) : base(baseAddress)
    {
    }
}

/// <summary>
/// Represents a <#= proc.Substring(3) #> assembler base class for generating machine code and managing labels.
/// </summary>
public abstract partial class <#= proc #>Assembler<TAsm> : Mos6502AssemblerBase<TAsm> where TAsm : <#= proc #>Assembler<TAsm>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="<#= proc #>Assembler"/> class.
    /// </summary>
    /// <param name="baseAddress">The base address for code generation.</param>
    protected <#= proc #>Assembler(ushort baseAddress = 0xC000) : base(baseAddress)
    {
    }

    /// <summary>
    /// Adds an instruction to the assembler.
    /// </summary>
    /// <param name="instruction">The instruction to add.</param>
    /// <param name="debugFilePath">The file path for debugging information (optional).</param>
    /// <param name="debugLineNumber">The line number for debugging information (optional).</param>
    /// <returns>The current assembler instance.</returns>
    public TAsm AddInstruction(<#= proc #>Instruction instruction, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
    {
        if (!instruction.IsValid) throw new ArgumentException("Invalid instruction", nameof(instruction));

        var sizeInBytes = instruction.SizeInBytes;
        Debug.Assert(sizeInBytes > 0);

        var totalSizeInBytes = SafeAddress(SizeInBytes + (byte)sizeInBytes);
        var currentAddress = CurrentAddress;

        var span = GetBuffer(sizeInBytes);
        instruction.AsSpan.CopyTo(span);
        SizeInBytes = totalSizeInBytes;
        CurrentCycleCount += instruction.CycleCount;
        CurrentOffset += (ushort)sizeInBytes;

        // Log debug information for the instruction
        DebugMap?.LogDebugInfo(new(currentAddress, Mos6502AssemblerDebugInfoKind.LineInfo, debugFilePath, debugLineNumber));

        return (TAsm)this;
    }

    /// <summary>
    /// Adds an instruction to the assembler, possibly referencing a label.
    /// </summary>
    /// <param name="instruction">The instruction to add.</param>
    /// <param name="expression">The expression.</param>
    /// <param name="debugFilePath">The file path for debugging information (optional).</param>
    /// <param name="debugLineNumber">The line number for debugging information (optional).</param>
    /// <returns>The current assembler instance.</returns>
    public TAsm AddInstruction(<#= proc #>Instruction instruction, Mos6502Expression expression, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
    {
        var currentAddress = CurrentAddress;
        var bufferOffset = SizeInBytes;
        // ReSharper disable ExplicitCallerInfoArgument
        AddInstruction(instruction, debugFilePath, debugLineNumber);
        // ReSharper restore ExplicitCallerInfoArgument

        Patches.Add(new(currentAddress, (ushort)(bufferOffset + 1), instruction.AddressingMode, expression));

        return (TAsm)this;
    }
}
<# } #>