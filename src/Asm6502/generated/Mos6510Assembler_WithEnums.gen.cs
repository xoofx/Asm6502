// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.
// ------------------------------------------------------------------------------
// This code was generated by Asm6502.CodeGen.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// ------------------------------------------------------------------------------
// ReSharper disable All
// ------------------------------------------------------------------------------
using System.Runtime.CompilerServices;

namespace Asm6502;

partial class Mos6510Assembler
{
    /// <summary>
    /// Add with carry. ADC_Imm instruction (0x69) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: C, Z, V, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler ADC_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.ADC_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then LSR. ALR_Imm instruction (0x4b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler ALR_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.ALR_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then set carry. ANC_2B_Imm instruction (0x2b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler ANC_2B_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.ANC_2B_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then set carry. ANC_Imm instruction (0x0b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler ANC_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.ANC_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND_Imm instruction (0x29) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler AND_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.AND_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Undocumented: AND with X then AND operand. ANE_Imm instruction (0x8b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal and unstable instruction.
    /// </remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler ANE_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.ANE_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then ROR. ARR_Imm instruction (0x6b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler ARR_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.ARR_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP_Imm instruction (0xc9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: C, Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler CMP_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.CMP_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare X register. CPX_Imm instruction (0xe0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: C, Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler CPX_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.CPX_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare Y register. CPY_Imm instruction (0xc0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: C, Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler CPY_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.CPY_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR_Imm instruction (0x49) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler EOR_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.EOR_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA_Imm instruction (0xa9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler LDA_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.LDA_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX_Imm instruction (0xa2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler LDX_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.LDX_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY_Imm instruction (0xa0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler LDY_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.LDY_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LXA_Imm instruction (0xab) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal and unstable instruction.
    /// </remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler LXA_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.LXA_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_82_Imm instruction (0x82) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler NOP_82_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.NOP_82_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_89_Imm instruction (0x89) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler NOP_89_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.NOP_89_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_C2_Imm instruction (0xc2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler NOP_C2_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.NOP_C2_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_E2_Imm instruction (0xe2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler NOP_E2_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.NOP_E2_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_Imm instruction (0x80) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler NOP_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.NOP_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA_Imm instruction (0x09) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: Z, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler ORA_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.ORA_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC_Imm instruction (0xe9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    ///  Flags: C, Z, V, N
    /// </code>
    /// </remarks>
    public Mos6510Assembler SBC_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.SBC_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compute (A AND X) then subtract with carry. SBX_Imm instruction (0xcb) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler SBX_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.SBX_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
    /// <summary>
    /// SBC with NOP behavior. USBC_Imm instruction (0xeb) with addressing mode Immediate.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Cycles: 2
    ///   Size: 2
    /// </code>
    ///  This is an illegal instruction.
    /// </remarks>
    public Mos6510Assembler USBC_Imm<TEnum>(TEnum immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0) where TEnum : struct, Enum
        => AddInstruction(Mos6510InstructionFactory.USBC_Imm(Unsafe.As<TEnum, byte>(ref immediate)), debugFilePath, debugLineNumber);
}
