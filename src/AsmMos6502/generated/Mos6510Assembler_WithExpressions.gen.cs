// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.
// ------------------------------------------------------------------------------
// This code was generated by AsmMos6502.CodeGen.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// ------------------------------------------------------------------------------
// ReSharper disable All
// ------------------------------------------------------------------------------
using System.Runtime.CompilerServices;

namespace AsmMos6502;

partial class Mos6510Assembler
{
    /// <summary>
    /// Add with carry. ADC instruction (0x61) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x71) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x6d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ADC(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x7d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ADC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x79) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ADC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x65) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x75) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC_Imm instruction (0x69) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then LSR. ALR_Imm instruction (0x4b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ALR_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ALR_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then set carry. ANC_2B_Imm instruction (0x2b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ANC_2B_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ANC_2B_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then set carry. ANC_Imm instruction (0x0b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ANC_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ANC_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x21) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x31) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x2d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler AND(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x3d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler AND(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x39) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler AND(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x25) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x35) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND_Imm instruction (0x29) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Undocumented: AND with X then AND operand. ANE_Imm instruction (0x8b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler ANE_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ANE_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then ROR. ARR_Imm instruction (0x6b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ARR_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ARR_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x0e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler ASL(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x1e) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler ASL(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x06) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ASL(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x16) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ASL(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if carry clear. BCC instruction (0x90) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BCC(Expressions.Mos6502ExpressionU16 relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BCC((sbyte)0), relativeAddress, debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if carry set. BCS instruction (0xb0) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BCS(Expressions.Mos6502ExpressionU16 relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BCS((sbyte)0), relativeAddress, debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if equal. BEQ instruction (0xf0) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BEQ(Expressions.Mos6502ExpressionU16 relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BEQ((sbyte)0), relativeAddress, debugFilePath, debugLineNumber);
    /// <summary>
    /// Bit test. BIT instruction (0x2c) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler BIT(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BIT((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Bit test. BIT instruction (0x24) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler BIT(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BIT((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if minus. BMI instruction (0x30) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BMI(Expressions.Mos6502ExpressionU16 relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BMI((sbyte)0), relativeAddress, debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if not equal. BNE instruction (0xd0) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BNE(Expressions.Mos6502ExpressionU16 relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BNE((sbyte)0), relativeAddress, debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if positive. BPL instruction (0x10) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BPL(Expressions.Mos6502ExpressionU16 relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BPL((sbyte)0), relativeAddress, debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if overflow clear. BVC instruction (0x50) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BVC(Expressions.Mos6502ExpressionU16 relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BVC((sbyte)0), relativeAddress, debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if overflow set. BVS instruction (0x70) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BVS(Expressions.Mos6502ExpressionU16 relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BVS((sbyte)0), relativeAddress, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xc1) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xd1) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xcd) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CMP(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xdd) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CMP(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xd9) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CMP(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xc5) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xd5) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP_Imm instruction (0xc9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare X register. CPX instruction (0xec) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CPX(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPX((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare X register. CPX instruction (0xe4) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler CPX(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPX((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare X register. CPX_Imm instruction (0xe0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler CPX_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPX_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare Y register. CPY instruction (0xcc) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CPY(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPY((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare Y register. CPY instruction (0xc4) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler CPY(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPY((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare Y register. CPY_Imm instruction (0xc0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler CPY_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPY_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xc3) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xd3) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xcf) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xdf) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xdb) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xc7) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xd7) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement memory. DEC instruction (0xce) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler DEC(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEC((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement memory. DEC instruction (0xde) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler DEC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEC((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement memory. DEC instruction (0xc6) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler DEC(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEC((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement memory. DEC instruction (0xd6) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler DEC(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEC((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x41) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x51) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x4d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler EOR(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x5d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler EOR(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x59) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler EOR(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x45) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x55) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR_Imm instruction (0x49) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment memory. INC instruction (0xee) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler INC(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INC((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment memory. INC instruction (0xfe) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler INC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INC((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment memory. INC instruction (0xe6) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler INC(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INC((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment memory. INC instruction (0xf6) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler INC(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INC((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xe3) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xf3) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xef) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xff) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xfb) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xe7) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xf7) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Unconditional Jump. JMP instruction (0x6c) with addressing mode Indirect.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes.</remarks>
    public Mos6510Assembler JMP(Expressions.Mos6502ExpressionIndirectU16 indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JMP(new Mos6502Indirect(0)), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Unconditional Jump. JMP instruction (0x4c) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 3 bytes.</remarks>
    public Mos6510Assembler JMP(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JMP((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Jump to subroutine. JSR instruction (0x20) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler JSR(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JSR((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator and transfer SP to X. LAS instruction (0xbb) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAS(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAS((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xa3) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xb3) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xaf) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xbf) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xa7) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xb7) with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX((byte)0, y), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xa1) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xb1) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xad) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDA(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xbd) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xb9) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xa5) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xb5) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA_Imm instruction (0xa9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xae) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDX(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xbe) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDX(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xa6) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDX(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xb6) with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDX(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX((byte)0, y), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX_Imm instruction (0xa2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDX_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xac) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDY(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xbc) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDY(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xa4) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDY(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xb4) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDY(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY_Imm instruction (0xa0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDY_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x4e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler LSR(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x5e) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler LSR(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x46) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler LSR(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x56) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler LSR(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LXA_Imm instruction (0xab) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler LXA_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LXA_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x0c) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x1c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x04) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x14) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_34 instruction (0x34) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_34(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_34((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_3C instruction (0x3c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_3C(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_3C((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_44 instruction (0x44) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_44(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_44((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_54 instruction (0x54) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_54(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_54((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_5C instruction (0x5c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_5C(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_5C((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_64 instruction (0x64) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_64(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_64((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_74 instruction (0x74) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_74(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_74((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_7C instruction (0x7c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_7C(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_7C((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_82_Imm instruction (0x82) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_82_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_82_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_89_Imm instruction (0x89) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_89_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_89_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_C2_Imm instruction (0xc2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_C2_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_C2_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_D4 instruction (0xd4) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_D4(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_D4((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_DC instruction (0xdc) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_DC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_DC((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_E2_Imm instruction (0xe2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_E2_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_E2_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_F4 instruction (0xf4) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_F4(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_F4((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_FC instruction (0xfc) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_FC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_FC((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_Imm instruction (0x80) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x01) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x11) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x0d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ORA(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x1d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ORA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x19) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ORA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x05) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x15) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA_Imm instruction (0x09) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x23) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x33) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x2f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x3f) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x3b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x27) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x37) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x2e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler ROL(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x3e) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler ROL(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x26) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ROL(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x36) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ROL(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x6e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler ROR(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x7e) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler ROR(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x66) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ROR(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x76) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ROR(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x63) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x73) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x6f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x7f) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x7b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x67) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x77) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator AND X. SAX instruction (0x83) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SAX(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SAX((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator AND X. SAX instruction (0x8f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SAX(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SAX((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator AND X. SAX instruction (0x87) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SAX(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SAX((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator AND X. SAX instruction (0x97) with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SAX(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SAX((byte)0, y), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xe1) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xf1) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xed) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler SBC(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xfd) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler SBC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xf9) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler SBC(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xe5) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xf5) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC_Imm instruction (0xe9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Compute (A AND X) then subtract with carry. SBX_Imm instruction (0xcb) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SBX_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBX_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store A AND X AND (high address + 1). SHA instruction (0x93) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler SHA(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SHA((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store A AND X AND (high address + 1). SHA instruction (0x9f) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SHA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SHA((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store A AND X AND (high address + 1). SHX instruction (0x9e) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler SHX(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SHX((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store Y AND (high address + 1). SHY instruction (0x9c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler SHY(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SHY((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x03) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x13) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x0f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x1f) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x1b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x07) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x17) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x43) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x53) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x4f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x5f) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x5b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x47) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x57) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x81) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler STA(Expressions.Mos6502ExpressionIndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA((Mos6502IndirectX)0), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x91) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler STA(Expressions.Mos6502ExpressionIndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA((Mos6502IndirectY)0, y), indirect, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x8d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler STA(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x9d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes.</remarks>
    public Mos6510Assembler STA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA((ushort)0, x), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x99) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes.</remarks>
    public Mos6510Assembler STA(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x85) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler STA(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x95) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler STA(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store X register. STX instruction (0x8e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler STX(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STX((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store X register. STX instruction (0x86) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler STX(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STX((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store X register. STX instruction (0x96) with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler STX(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STX((byte)0, y), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store Y register. STY instruction (0x8c) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler STY(Expressions.Mos6502ExpressionU16 address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STY((ushort)0), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store Y register. STY instruction (0x84) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler STY(Expressions.Mos6502ExpressionU8 zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STY((byte)0), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Store Y register. STY instruction (0x94) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler STY(Expressions.Mos6502ExpressionU8 zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STY((byte)0, x), zeroPage, debugFilePath, debugLineNumber);
    /// <summary>
    /// Transfer A AND X to SP, store A AND X AND (high address + 1). TAS instruction (0x9b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler TAS(Expressions.Mos6502ExpressionU16 address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.TAS((ushort)0, y), address, debugFilePath, debugLineNumber);
    /// <summary>
    /// SBC with NOP behavior. USBC_Imm instruction (0xeb) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler USBC_Imm(Expressions.Mos6502ExpressionU8 immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.USBC_Imm((byte)0), immediate, debugFilePath, debugLineNumber);
}
