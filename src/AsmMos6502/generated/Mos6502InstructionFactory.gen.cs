// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.
// ------------------------------------------------------------------------------
// This code was generated by AsmMos6502.CodeGen.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// ------------------------------------------------------------------------------
// ReSharper disable All
// ------------------------------------------------------------------------------
using System.Runtime.CompilerServices;

namespace AsmMos6502;

/// <summary>
/// Factory for all Mos6502 instructions.
/// </summary>
public static partial class Mos6502InstructionFactory
{
    /// <summary>
    /// Creates the ADC instruction (0x6d) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Add with carry. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ADC(ushort address) => new (Mos6502OpCode.ADC_Absolute, address);
    
    /// <summary>
    /// Creates the ADC instruction (0x7d) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Add with carry. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ADC(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.ADC_AbsoluteX, address);
    
    /// <summary>
    /// Creates the ADC instruction (0x79) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Add with carry. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ADC(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.ADC_AbsoluteY, address);
    
    /// <summary>
    /// Creates the ADC instruction (0x69) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Add with carry. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ADC_Imm(byte immediate) => new (Mos6502OpCode.ADC_Immediate, immediate);
    
    /// <summary>
    /// Creates the ADC instruction (0x61) instruction with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Add with carry. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ADC(Mos6502IndirectX indirect) => new (Mos6502OpCode.ADC_IndirectX, indirect.Address);
    
    /// <summary>
    /// Creates the ADC instruction (0x71) instruction with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Add with carry. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ADC(Mos6502IndirectY indirect, Mos6502RegisterY y) => new (Mos6502OpCode.ADC_IndirectY, indirect.Address);
    
    /// <summary>
    /// Creates the ADC instruction (0x65) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Add with carry. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ADC(byte zeroPage) => new (Mos6502OpCode.ADC_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the ADC instruction (0x75) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Add with carry. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ADC(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.ADC_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the AND instruction (0x2d) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Logical AND. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction AND(ushort address) => new (Mos6502OpCode.AND_Absolute, address);
    
    /// <summary>
    /// Creates the AND instruction (0x3d) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Logical AND. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction AND(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.AND_AbsoluteX, address);
    
    /// <summary>
    /// Creates the AND instruction (0x39) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Logical AND. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction AND(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.AND_AbsoluteY, address);
    
    /// <summary>
    /// Creates the AND instruction (0x29) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Logical AND. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction AND_Imm(byte immediate) => new (Mos6502OpCode.AND_Immediate, immediate);
    
    /// <summary>
    /// Creates the AND instruction (0x21) instruction with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Logical AND. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction AND(Mos6502IndirectX indirect) => new (Mos6502OpCode.AND_IndirectX, indirect.Address);
    
    /// <summary>
    /// Creates the AND instruction (0x31) instruction with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Logical AND. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction AND(Mos6502IndirectY indirect, Mos6502RegisterY y) => new (Mos6502OpCode.AND_IndirectY, indirect.Address);
    
    /// <summary>
    /// Creates the AND instruction (0x25) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Logical AND. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction AND(byte zeroPage) => new (Mos6502OpCode.AND_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the AND instruction (0x35) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Logical AND. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction AND(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.AND_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the ASL instruction (0x0e) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Arithmetic shift left. Cycles: 6, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ASL(ushort address) => new (Mos6502OpCode.ASL_Absolute, address);
    
    /// <summary>
    /// Creates the ASL instruction (0x1e) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Arithmetic shift left. Cycles: 7, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ASL(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.ASL_AbsoluteX, address);
    
    /// <summary>
    /// Creates the ASL instruction (0x0a) instruction with addressing mode Accumulator.
    /// </summary>
    /// <remarks>Arithmetic shift left. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ASL(Mos6502RegisterA accumulator = Mos6502RegisterA.A) => new (Mos6502OpCode.ASL_Accumulator);
    
    /// <summary>
    /// Creates the ASL instruction (0x06) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Arithmetic shift left. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ASL(byte zeroPage) => new (Mos6502OpCode.ASL_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the ASL instruction (0x16) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Arithmetic shift left. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ASL(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.ASL_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the BCC instruction (0x90) instruction with addressing mode Relative.
    /// </summary>
    /// <remarks>Branch if carry clear. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BCC(sbyte relativeAddress) => new (Mos6502OpCode.BCC_Relative, relativeAddress);
    
    /// <summary>
    /// Creates the BCS instruction (0xb0) instruction with addressing mode Relative.
    /// </summary>
    /// <remarks>Branch if carry set. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BCS(sbyte relativeAddress) => new (Mos6502OpCode.BCS_Relative, relativeAddress);
    
    /// <summary>
    /// Creates the BEQ instruction (0xf0) instruction with addressing mode Relative.
    /// </summary>
    /// <remarks>Branch if equal. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BEQ(sbyte relativeAddress) => new (Mos6502OpCode.BEQ_Relative, relativeAddress);
    
    /// <summary>
    /// Creates the BIT instruction (0x2c) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Bit test. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BIT(ushort address) => new (Mos6502OpCode.BIT_Absolute, address);
    
    /// <summary>
    /// Creates the BIT instruction (0x24) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Bit test. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BIT(byte zeroPage) => new (Mos6502OpCode.BIT_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the BMI instruction (0x30) instruction with addressing mode Relative.
    /// </summary>
    /// <remarks>Branch if minus. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BMI(sbyte relativeAddress) => new (Mos6502OpCode.BMI_Relative, relativeAddress);
    
    /// <summary>
    /// Creates the BNE instruction (0xd0) instruction with addressing mode Relative.
    /// </summary>
    /// <remarks>Branch if not equal. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BNE(sbyte relativeAddress) => new (Mos6502OpCode.BNE_Relative, relativeAddress);
    
    /// <summary>
    /// Creates the BPL instruction (0x10) instruction with addressing mode Relative.
    /// </summary>
    /// <remarks>Branch if positive. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BPL(sbyte relativeAddress) => new (Mos6502OpCode.BPL_Relative, relativeAddress);
    
    /// <summary>
    /// Creates the BRK instruction (0x00) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Break / Software Interrupt. Cycles: 7, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BRK() => new (Mos6502OpCode.BRK_Implied);
    
    /// <summary>
    /// Creates the BVC instruction (0x50) instruction with addressing mode Relative.
    /// </summary>
    /// <remarks>Branch if overflow clear. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BVC(sbyte relativeAddress) => new (Mos6502OpCode.BVC_Relative, relativeAddress);
    
    /// <summary>
    /// Creates the BVS instruction (0x70) instruction with addressing mode Relative.
    /// </summary>
    /// <remarks>Branch if overflow set. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction BVS(sbyte relativeAddress) => new (Mos6502OpCode.BVS_Relative, relativeAddress);
    
    /// <summary>
    /// Creates the CLC instruction (0x18) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Clear carry. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CLC() => new (Mos6502OpCode.CLC_Implied);
    
    /// <summary>
    /// Creates the CLD instruction (0xd8) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Clear decimal mode. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CLD() => new (Mos6502OpCode.CLD_Implied);
    
    /// <summary>
    /// Creates the CLI instruction (0x58) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Clear interrupt disable. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CLI() => new (Mos6502OpCode.CLI_Implied);
    
    /// <summary>
    /// Creates the CLV instruction (0xb8) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Clear overflow flag. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CLV() => new (Mos6502OpCode.CLV_Implied);
    
    /// <summary>
    /// Creates the CMP instruction (0xcd) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Compare. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CMP(ushort address) => new (Mos6502OpCode.CMP_Absolute, address);
    
    /// <summary>
    /// Creates the CMP instruction (0xdd) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Compare. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CMP(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.CMP_AbsoluteX, address);
    
    /// <summary>
    /// Creates the CMP instruction (0xd9) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Compare. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CMP(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.CMP_AbsoluteY, address);
    
    /// <summary>
    /// Creates the CMP instruction (0xc9) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Compare. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CMP_Imm(byte immediate) => new (Mos6502OpCode.CMP_Immediate, immediate);
    
    /// <summary>
    /// Creates the CMP instruction (0xc1) instruction with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Compare. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CMP(Mos6502IndirectX indirect) => new (Mos6502OpCode.CMP_IndirectX, indirect.Address);
    
    /// <summary>
    /// Creates the CMP instruction (0xd1) instruction with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Compare. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CMP(Mos6502IndirectY indirect, Mos6502RegisterY y) => new (Mos6502OpCode.CMP_IndirectY, indirect.Address);
    
    /// <summary>
    /// Creates the CMP instruction (0xc5) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Compare. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CMP(byte zeroPage) => new (Mos6502OpCode.CMP_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the CMP instruction (0xd5) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Compare. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CMP(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.CMP_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the CPX instruction (0xec) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Compare X register. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CPX(ushort address) => new (Mos6502OpCode.CPX_Absolute, address);
    
    /// <summary>
    /// Creates the CPX instruction (0xe0) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Compare X register. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CPX_Imm(byte immediate) => new (Mos6502OpCode.CPX_Immediate, immediate);
    
    /// <summary>
    /// Creates the CPX instruction (0xe4) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Compare X register. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CPX(byte zeroPage) => new (Mos6502OpCode.CPX_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the CPY instruction (0xcc) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Compare Y register. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CPY(ushort address) => new (Mos6502OpCode.CPY_Absolute, address);
    
    /// <summary>
    /// Creates the CPY instruction (0xc0) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Compare Y register. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CPY_Imm(byte immediate) => new (Mos6502OpCode.CPY_Immediate, immediate);
    
    /// <summary>
    /// Creates the CPY instruction (0xc4) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Compare Y register. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction CPY(byte zeroPage) => new (Mos6502OpCode.CPY_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the DEC instruction (0xce) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Decrement memory. Cycles: 6, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction DEC(ushort address) => new (Mos6502OpCode.DEC_Absolute, address);
    
    /// <summary>
    /// Creates the DEC instruction (0xde) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Decrement memory. Cycles: 7, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction DEC(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.DEC_AbsoluteX, address);
    
    /// <summary>
    /// Creates the DEC instruction (0xc6) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Decrement memory. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction DEC(byte zeroPage) => new (Mos6502OpCode.DEC_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the DEC instruction (0xd6) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Decrement memory. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction DEC(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.DEC_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the DEX instruction (0xca) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Decrement X register. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction DEX() => new (Mos6502OpCode.DEX_Implied);
    
    /// <summary>
    /// Creates the DEY instruction (0x88) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Decrement Y register. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction DEY() => new (Mos6502OpCode.DEY_Implied);
    
    /// <summary>
    /// Creates the EOR instruction (0x4d) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Logical Exclusive OR (XOR). Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction EOR(ushort address) => new (Mos6502OpCode.EOR_Absolute, address);
    
    /// <summary>
    /// Creates the EOR instruction (0x5d) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Logical Exclusive OR (XOR). Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction EOR(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.EOR_AbsoluteX, address);
    
    /// <summary>
    /// Creates the EOR instruction (0x59) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Logical Exclusive OR (XOR). Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction EOR(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.EOR_AbsoluteY, address);
    
    /// <summary>
    /// Creates the EOR instruction (0x49) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Logical Exclusive OR (XOR). Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction EOR_Imm(byte immediate) => new (Mos6502OpCode.EOR_Immediate, immediate);
    
    /// <summary>
    /// Creates the EOR instruction (0x41) instruction with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Logical Exclusive OR (XOR). Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction EOR(Mos6502IndirectX indirect) => new (Mos6502OpCode.EOR_IndirectX, indirect.Address);
    
    /// <summary>
    /// Creates the EOR instruction (0x51) instruction with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Logical Exclusive OR (XOR). Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction EOR(Mos6502IndirectY indirect, Mos6502RegisterY y) => new (Mos6502OpCode.EOR_IndirectY, indirect.Address);
    
    /// <summary>
    /// Creates the EOR instruction (0x45) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Logical Exclusive OR (XOR). Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction EOR(byte zeroPage) => new (Mos6502OpCode.EOR_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the EOR instruction (0x55) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Logical Exclusive OR (XOR). Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction EOR(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.EOR_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the INC instruction (0xee) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Increment memory. Cycles: 6, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction INC(ushort address) => new (Mos6502OpCode.INC_Absolute, address);
    
    /// <summary>
    /// Creates the INC instruction (0xfe) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Increment memory. Cycles: 7, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction INC(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.INC_AbsoluteX, address);
    
    /// <summary>
    /// Creates the INC instruction (0xe6) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Increment memory. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction INC(byte zeroPage) => new (Mos6502OpCode.INC_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the INC instruction (0xf6) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Increment memory. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction INC(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.INC_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the INX instruction (0xe8) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Increment X register. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction INX() => new (Mos6502OpCode.INX_Implied);
    
    /// <summary>
    /// Creates the INY instruction (0xc8) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Increment Y register. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction INY() => new (Mos6502OpCode.INY_Implied);
    
    /// <summary>
    /// Creates the JMP instruction (0x4c) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Unconditional Jump. Cycles: 3, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction JMP(ushort address) => new (Mos6502OpCode.JMP_Absolute, address);
    
    /// <summary>
    /// Creates the JMP instruction (0x6c) instruction with addressing mode Indirect.
    /// </summary>
    /// <remarks>Unconditional Jump. Cycles: 5, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction JMP(Mos6502Indirect indirect) => new (Mos6502OpCode.JMP_Indirect, indirect.Address);
    
    /// <summary>
    /// Creates the JSR instruction (0x20) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Jump to subroutine. Cycles: 6, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction JSR(ushort address) => new (Mos6502OpCode.JSR_Absolute, address);
    
    /// <summary>
    /// Creates the LDA instruction (0xad) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Load accumulator. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDA(ushort address) => new (Mos6502OpCode.LDA_Absolute, address);
    
    /// <summary>
    /// Creates the LDA instruction (0xbd) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Load accumulator. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDA(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.LDA_AbsoluteX, address);
    
    /// <summary>
    /// Creates the LDA instruction (0xb9) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Load accumulator. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDA(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.LDA_AbsoluteY, address);
    
    /// <summary>
    /// Creates the LDA instruction (0xa9) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Load accumulator. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDA_Imm(byte immediate) => new (Mos6502OpCode.LDA_Immediate, immediate);
    
    /// <summary>
    /// Creates the LDA instruction (0xa1) instruction with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Load accumulator. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDA(Mos6502IndirectX indirect) => new (Mos6502OpCode.LDA_IndirectX, indirect.Address);
    
    /// <summary>
    /// Creates the LDA instruction (0xb1) instruction with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Load accumulator. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDA(Mos6502IndirectY indirect, Mos6502RegisterY y) => new (Mos6502OpCode.LDA_IndirectY, indirect.Address);
    
    /// <summary>
    /// Creates the LDA instruction (0xa5) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Load accumulator. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDA(byte zeroPage) => new (Mos6502OpCode.LDA_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the LDA instruction (0xb5) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Load accumulator. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDA(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.LDA_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the LDX instruction (0xae) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Load X register. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDX(ushort address) => new (Mos6502OpCode.LDX_Absolute, address);
    
    /// <summary>
    /// Creates the LDX instruction (0xbe) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Load X register. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDX(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.LDX_AbsoluteY, address);
    
    /// <summary>
    /// Creates the LDX instruction (0xa2) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Load X register. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDX_Imm(byte immediate) => new (Mos6502OpCode.LDX_Immediate, immediate);
    
    /// <summary>
    /// Creates the LDX instruction (0xa6) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Load X register. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDX(byte zeroPage) => new (Mos6502OpCode.LDX_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the LDX instruction (0xb6) instruction with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Load X register. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDX(byte zeroPage, Mos6502RegisterY y) => new (Mos6502OpCode.LDX_ZeroPageY, zeroPage);
    
    /// <summary>
    /// Creates the LDY instruction (0xac) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Load Y register. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDY(ushort address) => new (Mos6502OpCode.LDY_Absolute, address);
    
    /// <summary>
    /// Creates the LDY instruction (0xbc) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Load Y register. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDY(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.LDY_AbsoluteX, address);
    
    /// <summary>
    /// Creates the LDY instruction (0xa0) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Load Y register. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDY_Imm(byte immediate) => new (Mos6502OpCode.LDY_Immediate, immediate);
    
    /// <summary>
    /// Creates the LDY instruction (0xa4) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Load Y register. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDY(byte zeroPage) => new (Mos6502OpCode.LDY_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the LDY instruction (0xb4) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Load Y register. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LDY(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.LDY_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the LSR instruction (0x4e) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Logical shift right. Cycles: 6, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LSR(ushort address) => new (Mos6502OpCode.LSR_Absolute, address);
    
    /// <summary>
    /// Creates the LSR instruction (0x5e) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Logical shift right. Cycles: 7, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LSR(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.LSR_AbsoluteX, address);
    
    /// <summary>
    /// Creates the LSR instruction (0x4a) instruction with addressing mode Accumulator.
    /// </summary>
    /// <remarks>Logical shift right. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LSR(Mos6502RegisterA accumulator = Mos6502RegisterA.A) => new (Mos6502OpCode.LSR_Accumulator);
    
    /// <summary>
    /// Creates the LSR instruction (0x46) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Logical shift right. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LSR(byte zeroPage) => new (Mos6502OpCode.LSR_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the LSR instruction (0x56) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Logical shift right. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction LSR(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.LSR_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the NOP instruction (0xea) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>No operation. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction NOP() => new (Mos6502OpCode.NOP_Implied);
    
    /// <summary>
    /// Creates the ORA instruction (0x0d) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Logical Inclusive OR. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ORA(ushort address) => new (Mos6502OpCode.ORA_Absolute, address);
    
    /// <summary>
    /// Creates the ORA instruction (0x1d) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Logical Inclusive OR. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ORA(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.ORA_AbsoluteX, address);
    
    /// <summary>
    /// Creates the ORA instruction (0x19) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Logical Inclusive OR. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ORA(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.ORA_AbsoluteY, address);
    
    /// <summary>
    /// Creates the ORA instruction (0x09) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Logical Inclusive OR. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ORA_Imm(byte immediate) => new (Mos6502OpCode.ORA_Immediate, immediate);
    
    /// <summary>
    /// Creates the ORA instruction (0x01) instruction with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Logical Inclusive OR. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ORA(Mos6502IndirectX indirect) => new (Mos6502OpCode.ORA_IndirectX, indirect.Address);
    
    /// <summary>
    /// Creates the ORA instruction (0x11) instruction with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Logical Inclusive OR. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ORA(Mos6502IndirectY indirect, Mos6502RegisterY y) => new (Mos6502OpCode.ORA_IndirectY, indirect.Address);
    
    /// <summary>
    /// Creates the ORA instruction (0x05) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Logical Inclusive OR. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ORA(byte zeroPage) => new (Mos6502OpCode.ORA_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the ORA instruction (0x15) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Logical Inclusive OR. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ORA(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.ORA_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the PHA instruction (0x48) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Push accumulator. Cycles: 3, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction PHA() => new (Mos6502OpCode.PHA_Implied);
    
    /// <summary>
    /// Creates the PHP instruction (0x08) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Push processor status. Cycles: 3, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction PHP() => new (Mos6502OpCode.PHP_Implied);
    
    /// <summary>
    /// Creates the PLA instruction (0x68) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Pull accumulator. Cycles: 4, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction PLA() => new (Mos6502OpCode.PLA_Implied);
    
    /// <summary>
    /// Creates the PLP instruction (0x28) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Pull processor status. Cycles: 4, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction PLP() => new (Mos6502OpCode.PLP_Implied);
    
    /// <summary>
    /// Creates the ROL instruction (0x2e) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Rotate left. Cycles: 6, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROL(ushort address) => new (Mos6502OpCode.ROL_Absolute, address);
    
    /// <summary>
    /// Creates the ROL instruction (0x3e) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Rotate left. Cycles: 7, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROL(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.ROL_AbsoluteX, address);
    
    /// <summary>
    /// Creates the ROL instruction (0x2a) instruction with addressing mode Accumulator.
    /// </summary>
    /// <remarks>Rotate left. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROL(Mos6502RegisterA accumulator = Mos6502RegisterA.A) => new (Mos6502OpCode.ROL_Accumulator);
    
    /// <summary>
    /// Creates the ROL instruction (0x26) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Rotate left. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROL(byte zeroPage) => new (Mos6502OpCode.ROL_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the ROL instruction (0x36) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Rotate left. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROL(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.ROL_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the ROR instruction (0x6e) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Rotate right. Cycles: 6, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROR(ushort address) => new (Mos6502OpCode.ROR_Absolute, address);
    
    /// <summary>
    /// Creates the ROR instruction (0x7e) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Rotate right. Cycles: 7, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROR(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.ROR_AbsoluteX, address);
    
    /// <summary>
    /// Creates the ROR instruction (0x6a) instruction with addressing mode Accumulator.
    /// </summary>
    /// <remarks>Rotate right. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROR(Mos6502RegisterA accumulator = Mos6502RegisterA.A) => new (Mos6502OpCode.ROR_Accumulator);
    
    /// <summary>
    /// Creates the ROR instruction (0x66) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Rotate right. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROR(byte zeroPage) => new (Mos6502OpCode.ROR_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the ROR instruction (0x76) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Rotate right. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction ROR(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.ROR_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the RTI instruction (0x40) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Return from interrupt. Cycles: 6, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction RTI() => new (Mos6502OpCode.RTI_Implied);
    
    /// <summary>
    /// Creates the RTS instruction (0x60) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Return from subroutine. Cycles: 6, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction RTS() => new (Mos6502OpCode.RTS_Implied);
    
    /// <summary>
    /// Creates the SBC instruction (0xed) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Subtract with carry. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SBC(ushort address) => new (Mos6502OpCode.SBC_Absolute, address);
    
    /// <summary>
    /// Creates the SBC instruction (0xfd) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Subtract with carry. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SBC(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.SBC_AbsoluteX, address);
    
    /// <summary>
    /// Creates the SBC instruction (0xf9) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Subtract with carry. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SBC(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.SBC_AbsoluteY, address);
    
    /// <summary>
    /// Creates the SBC instruction (0xe9) instruction with addressing mode Immediate.
    /// </summary>
    /// <remarks>Subtract with carry. Cycles: 2, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SBC_Imm(byte immediate) => new (Mos6502OpCode.SBC_Immediate, immediate);
    
    /// <summary>
    /// Creates the SBC instruction (0xe1) instruction with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Subtract with carry. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SBC(Mos6502IndirectX indirect) => new (Mos6502OpCode.SBC_IndirectX, indirect.Address);
    
    /// <summary>
    /// Creates the SBC instruction (0xf1) instruction with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Subtract with carry. Cycles: 5, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SBC(Mos6502IndirectY indirect, Mos6502RegisterY y) => new (Mos6502OpCode.SBC_IndirectY, indirect.Address);
    
    /// <summary>
    /// Creates the SBC instruction (0xe5) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Subtract with carry. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SBC(byte zeroPage) => new (Mos6502OpCode.SBC_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the SBC instruction (0xf5) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Subtract with carry. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SBC(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.SBC_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the SEC instruction (0x38) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Set carry. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SEC() => new (Mos6502OpCode.SEC_Implied);
    
    /// <summary>
    /// Creates the SED instruction (0xf8) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Set decimal flag. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SED() => new (Mos6502OpCode.SED_Implied);
    
    /// <summary>
    /// Creates the SEI instruction (0x78) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Set interrupt disable. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction SEI() => new (Mos6502OpCode.SEI_Implied);
    
    /// <summary>
    /// Creates the STA instruction (0x8d) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Store accumulator. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STA(ushort address) => new (Mos6502OpCode.STA_Absolute, address);
    
    /// <summary>
    /// Creates the STA instruction (0x9d) instruction with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Store accumulator. Cycles: 5, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STA(ushort address, Mos6502RegisterX x) => new (Mos6502OpCode.STA_AbsoluteX, address);
    
    /// <summary>
    /// Creates the STA instruction (0x99) instruction with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Store accumulator. Cycles: 5, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STA(ushort address, Mos6502RegisterY y) => new (Mos6502OpCode.STA_AbsoluteY, address);
    
    /// <summary>
    /// Creates the STA instruction (0x81) instruction with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Store accumulator. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STA(Mos6502IndirectX indirect) => new (Mos6502OpCode.STA_IndirectX, indirect.Address);
    
    /// <summary>
    /// Creates the STA instruction (0x91) instruction with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Store accumulator. Cycles: 6, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STA(Mos6502IndirectY indirect, Mos6502RegisterY y) => new (Mos6502OpCode.STA_IndirectY, indirect.Address);
    
    /// <summary>
    /// Creates the STA instruction (0x85) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Store accumulator. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STA(byte zeroPage) => new (Mos6502OpCode.STA_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the STA instruction (0x95) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Store accumulator. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STA(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.STA_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the STX instruction (0x8e) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Store X register. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STX(ushort address) => new (Mos6502OpCode.STX_Absolute, address);
    
    /// <summary>
    /// Creates the STX instruction (0x86) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Store X register. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STX(byte zeroPage) => new (Mos6502OpCode.STX_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the STX instruction (0x96) instruction with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Store X register. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STX(byte zeroPage, Mos6502RegisterY y) => new (Mos6502OpCode.STX_ZeroPageY, zeroPage);
    
    /// <summary>
    /// Creates the STY instruction (0x8c) instruction with addressing mode Absolute.
    /// </summary>
    /// <remarks>Store Y register. Cycles: 4, Size: 3 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STY(ushort address) => new (Mos6502OpCode.STY_Absolute, address);
    
    /// <summary>
    /// Creates the STY instruction (0x84) instruction with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Store Y register. Cycles: 3, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STY(byte zeroPage) => new (Mos6502OpCode.STY_ZeroPage, zeroPage);
    
    /// <summary>
    /// Creates the STY instruction (0x94) instruction with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Store Y register. Cycles: 4, Size: 2 bytes.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction STY(byte zeroPage, Mos6502RegisterX x) => new (Mos6502OpCode.STY_ZeroPageX, zeroPage);
    
    /// <summary>
    /// Creates the TAX instruction (0xaa) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Transfer acc to X. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction TAX() => new (Mos6502OpCode.TAX_Implied);
    
    /// <summary>
    /// Creates the TAY instruction (0xa8) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Transfer acc to Y. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction TAY() => new (Mos6502OpCode.TAY_Implied);
    
    /// <summary>
    /// Creates the TSX instruction (0xba) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Transfer stack pointer to X. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction TSX() => new (Mos6502OpCode.TSX_Implied);
    
    /// <summary>
    /// Creates the TXA instruction (0x8a) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Transfer X to acc. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction TXA() => new (Mos6502OpCode.TXA_Implied);
    
    /// <summary>
    /// Creates the TXS instruction (0x9a) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction TXS() => new (Mos6502OpCode.TXS_Implied);
    
    /// <summary>
    /// Creates the TYA instruction (0x98) instruction with addressing mode Implied.
    /// </summary>
    /// <remarks>Transfer Y to acc. Cycles: 2, Size: 1 byte.</remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Mos6502Instruction TYA() => new (Mos6502OpCode.TYA_Implied);
    
}
