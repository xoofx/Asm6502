// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.
// ------------------------------------------------------------------------------
// This code was generated by AsmMos6502.CodeGen.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// ------------------------------------------------------------------------------
// ReSharper disable All
// ------------------------------------------------------------------------------
using System.Runtime.CompilerServices;

namespace AsmMos6502;

partial class Mos6510Assembler
{
    /// <summary>
    /// Add with carry. ADC instruction (0x69) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x65) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x75) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x61) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x71) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ADC(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x6d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ADC(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x7d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ADC(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Add with carry. ADC instruction (0x79) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ADC(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ADC(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then LSR. ALR instruction (0x4b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ALR_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ALR_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then set carry. ANC instruction (0x0b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ANC_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ANC_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then set carry. ANC_2B instruction (0x2b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ANC_2B_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ANC_2B_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x29) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x25) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x35) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x21) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x31) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler AND(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x2d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler AND(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x3d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler AND(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical AND. AND instruction (0x39) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler AND(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.AND(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Undocumented: AND with X then AND operand. ANE instruction (0x8b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler ANE_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ANE_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// AND then ROR. ARR instruction (0x6b) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ARR_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ARR_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x06) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ASL(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x16) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ASL(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x0a) with addressing mode Accumulator.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler ASL(Mos6502RegisterA accumulator = Mos6502RegisterA.A, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x0e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler ASL(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Arithmetic shift left. ASL instruction (0x1e) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler ASL(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ASL(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if carry clear. BCC instruction (0x90) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BCC(sbyte relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BCC(relativeAddress), debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if carry set. BCS instruction (0xb0) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BCS(sbyte relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BCS(relativeAddress), debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if equal. BEQ instruction (0xf0) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BEQ(sbyte relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BEQ(relativeAddress), debugFilePath, debugLineNumber);
    /// <summary>
    /// Bit test. BIT instruction (0x24) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler BIT(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BIT(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Bit test. BIT instruction (0x2c) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler BIT(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BIT(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if minus. BMI instruction (0x30) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BMI(sbyte relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BMI(relativeAddress), debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if not equal. BNE instruction (0xd0) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BNE(sbyte relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BNE(relativeAddress), debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if positive. BPL instruction (0x10) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BPL(sbyte relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BPL(relativeAddress), debugFilePath, debugLineNumber);
    /// <summary>
    /// Break / Software Interrupt. BRK instruction (0x00) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 1 byte.</remarks>
    public Mos6510Assembler BRK([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BRK(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if overflow clear. BVC instruction (0x50) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BVC(sbyte relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BVC(relativeAddress), debugFilePath, debugLineNumber);
    /// <summary>
    /// Branch if overflow set. BVS instruction (0x70) with addressing mode Relative.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler BVS(sbyte relativeAddress, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.BVS(relativeAddress), debugFilePath, debugLineNumber);
    /// <summary>
    /// Clear carry. CLC instruction (0x18) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler CLC([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CLC(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Clear decimal mode. CLD instruction (0xd8) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler CLD([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CLD(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Clear interrupt disable. CLI instruction (0x58) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler CLI([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CLI(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Clear overflow flag. CLV instruction (0xb8) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler CLV([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CLV(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xc9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xc5) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xd5) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xc1) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xd1) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler CMP(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xcd) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CMP(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xdd) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CMP(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare. CMP instruction (0xd9) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CMP(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CMP(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare X register. CPX instruction (0xe0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler CPX_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPX_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare X register. CPX instruction (0xe4) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler CPX(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPX(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare X register. CPX instruction (0xec) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CPX(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPX(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare Y register. CPY instruction (0xc0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler CPY_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPY_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare Y register. CPY instruction (0xc4) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler CPY(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPY(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compare Y register. CPY instruction (0xcc) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler CPY(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.CPY(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xc7) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xd7) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xc3) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xd3) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xcf) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xdf) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// DEC then CMP. DCP instruction (0xdb) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler DCP(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DCP(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement memory. DEC instruction (0xc6) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler DEC(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEC(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement memory. DEC instruction (0xd6) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler DEC(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEC(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement memory. DEC instruction (0xce) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler DEC(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEC(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement memory. DEC instruction (0xde) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler DEC(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEC(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement X register. DEX instruction (0xca) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler DEX([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEX(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Decrement Y register. DEY instruction (0x88) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler DEY([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.DEY(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x49) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x45) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x55) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x41) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x51) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler EOR(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x4d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler EOR(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x5d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler EOR(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Exclusive OR (XOR). EOR instruction (0x59) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler EOR(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.EOR(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment memory. INC instruction (0xe6) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler INC(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INC(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment memory. INC instruction (0xf6) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler INC(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INC(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment memory. INC instruction (0xee) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler INC(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INC(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment memory. INC instruction (0xfe) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler INC(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INC(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment X register. INX instruction (0xe8) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler INX([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INX(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Increment Y register. INY instruction (0xc8) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler INY([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.INY(), debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xe7) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xf7) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xe3) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xf3) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xef) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xff) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// INC then SBC. ISC instruction (0xfb) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler ISC(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ISC(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM instruction (0x02) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_12 instruction (0x12) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_12([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_12(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_22 instruction (0x22) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_22([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_22(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_32 instruction (0x32) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_32([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_32(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_42 instruction (0x42) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_42([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_42(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_52 instruction (0x52) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_52([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_52(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_62 instruction (0x62) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_62([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_62(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_72 instruction (0x72) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_72([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_72(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_92 instruction (0x92) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_92([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_92(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_B2 instruction (0xb2) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_B2([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_B2(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_D2 instruction (0xd2) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_D2([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_D2(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jam the CPU (halt). JAM_F2 instruction (0xf2) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler JAM_F2([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JAM_F2(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Unconditional Jump. JMP instruction (0x6c) with addressing mode Indirect.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes.</remarks>
    public Mos6510Assembler JMP(Mos6502Indirect indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JMP(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Unconditional Jump. JMP instruction (0x4c) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 3 bytes.</remarks>
    public Mos6510Assembler JMP(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JMP(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Jump to subroutine. JSR instruction (0x20) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler JSR(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.JSR(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator and transfer SP to X. LAS instruction (0xbb) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAS(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAS(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xa7) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xb7) with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(byte zeroPage, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX(zeroPage, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xa3) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xb3) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xaf) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LAX instruction (0xbf) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler LAX(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LAX(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xa9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xa5) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xb5) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xa1) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xb1) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDA(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xad) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDA(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xbd) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDA(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load accumulator. LDA instruction (0xb9) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDA(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDA(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xa2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDX_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xa6) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDX(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xb6) with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDX(byte zeroPage, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX(zeroPage, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xae) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDX(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load X register. LDX instruction (0xbe) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDX(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDX(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xa0) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDY_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xa4) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDY(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xb4) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler LDY(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xac) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDY(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Load Y register. LDY instruction (0xbc) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler LDY(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LDY(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x46) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler LSR(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x56) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler LSR(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x4a) with addressing mode Accumulator.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler LSR(Mos6502RegisterA accumulator = Mos6502RegisterA.A, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x4e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler LSR(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical shift right. LSR instruction (0x5e) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler LSR(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LSR(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// LDA then LDX. LXA instruction (0xab) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler LXA_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.LXA_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x80) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0xea) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler NOP([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP(), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x04) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x14) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x0c) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP instruction (0x1c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_1A instruction (0x1a) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_1A([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_1A(), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_34 instruction (0x34) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_34(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_34(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_3A instruction (0x3a) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_3A([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_3A(), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_3C instruction (0x3c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_3C(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_3C(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_44 instruction (0x44) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_44(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_44(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_54 instruction (0x54) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_54(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_54(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_5A instruction (0x5a) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_5A([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_5A(), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_5C instruction (0x5c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_5C(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_5C(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_64 instruction (0x64) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_64(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_64(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_74 instruction (0x74) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_74(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_74(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_7A instruction (0x7a) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_7A([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_7A(), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_7C instruction (0x7c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_7C(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_7C(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_82 instruction (0x82) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_82_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_82_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_89 instruction (0x89) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_89_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_89_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_C2 instruction (0xc2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_C2_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_C2_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_D4 instruction (0xd4) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_D4(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_D4(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_DA instruction (0xda) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_DA([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_DA(), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_DC instruction (0xdc) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_DC(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_DC(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_E2 instruction (0xe2) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_E2_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_E2_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_F4 instruction (0xf4) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_F4(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_F4(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_FA instruction (0xfa) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_FA([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_FA(), debugFilePath, debugLineNumber);
    /// <summary>
    /// No operation. NOP_FC instruction (0xfc) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler NOP_FC(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.NOP_FC(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x09) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x05) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x15) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x01) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x11) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ORA(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x0d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ORA(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x1d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ORA(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Logical Inclusive OR. ORA instruction (0x19) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler ORA(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ORA(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Push accumulator. PHA instruction (0x48) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 1 byte.</remarks>
    public Mos6510Assembler PHA([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.PHA(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Push processor status. PHP instruction (0x08) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 1 byte.</remarks>
    public Mos6510Assembler PHP([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.PHP(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Pull accumulator. PLA instruction (0x68) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 1 byte.</remarks>
    public Mos6510Assembler PLA([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.PLA(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Pull processor status. PLP instruction (0x28) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 1 byte.</remarks>
    public Mos6510Assembler PLP([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.PLP(), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x27) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x37) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x23) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x33) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x2f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x3f) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROL then AND. RLA instruction (0x3b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RLA(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RLA(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x26) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ROL(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x36) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ROL(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x2a) with addressing mode Accumulator.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler ROL(Mos6502RegisterA accumulator = Mos6502RegisterA.A, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x2e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler ROL(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate left. ROL instruction (0x3e) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler ROL(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROL(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x66) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler ROR(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x76) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler ROR(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x6a) with addressing mode Accumulator.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler ROR(Mos6502RegisterA accumulator = Mos6502RegisterA.A, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x6e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes.</remarks>
    public Mos6510Assembler ROR(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Rotate right. ROR instruction (0x7e) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes.</remarks>
    public Mos6510Assembler ROR(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.ROR(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x67) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x77) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x63) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x73) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x6f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x7f) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// ROR then ADC. RRA instruction (0x7b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler RRA(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RRA(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Return from interrupt. RTI instruction (0x40) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 1 byte.</remarks>
    public Mos6510Assembler RTI([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RTI(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Return from subroutine. RTS instruction (0x60) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 1 byte.</remarks>
    public Mos6510Assembler RTS([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.RTS(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator AND X. SAX instruction (0x87) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SAX(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SAX(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator AND X. SAX instruction (0x97) with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SAX(byte zeroPage, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SAX(zeroPage, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator AND X. SAX instruction (0x83) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SAX(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SAX(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator AND X. SAX instruction (0x8f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SAX(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SAX(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xe9) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xe5) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xf5) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xe1) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xf1) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes.</remarks>
    public Mos6510Assembler SBC(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xed) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler SBC(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xfd) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler SBC(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Subtract with carry. SBC instruction (0xf9) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler SBC(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBC(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Compute (A AND X) then subtract with carry. SBX instruction (0xcb) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SBX_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SBX_Imm(immediate), debugFilePath, debugLineNumber);
    /// <summary>
    /// Set carry. SEC instruction (0x38) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler SEC([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SEC(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Set decimal flag. SED instruction (0xf8) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler SED([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SED(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Set interrupt disable. SEI instruction (0x78) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler SEI([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SEI(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store A AND X AND (high address + 1). SHA instruction (0x93) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler SHA(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SHA(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store A AND X AND (high address + 1). SHA instruction (0x9f) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SHA(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SHA(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store A AND X AND (high address + 1). SHX instruction (0x9e) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler SHX(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SHX(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store Y AND (high address + 1). SHY instruction (0x9c) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler SHY(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SHY(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x07) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x17) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x03) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x13) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x0f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x1f) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// ASL then ORA. SLO instruction (0x1b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SLO(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SLO(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x47) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x57) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x43) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x53) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 8, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x4f) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x5f) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// LSR then EOR. SRE instruction (0x5b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 7, Size: 3 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler SRE(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.SRE(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x85) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler STA(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x95) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler STA(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x81) with addressing mode IndirectX.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler STA(Mos6502IndirectX indirect, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA(indirect), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x91) with addressing mode IndirectY.
    /// </summary>
    /// <remarks>Cycles: 6, Size: 2 bytes.</remarks>
    public Mos6510Assembler STA(Mos6502IndirectY indirect, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA(indirect, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x8d) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler STA(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x9d) with addressing mode AbsoluteX.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes.</remarks>
    public Mos6510Assembler STA(ushort address, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA(address, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store accumulator. STA instruction (0x99) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes.</remarks>
    public Mos6510Assembler STA(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STA(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store X register. STX instruction (0x86) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler STX(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STX(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store X register. STX instruction (0x96) with addressing mode ZeroPageY.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler STX(byte zeroPage, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STX(zeroPage, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store X register. STX instruction (0x8e) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler STX(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STX(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store Y register. STY instruction (0x84) with addressing mode ZeroPage.
    /// </summary>
    /// <remarks>Cycles: 3, Size: 2 bytes.</remarks>
    public Mos6510Assembler STY(byte zeroPage, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STY(zeroPage), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store Y register. STY instruction (0x94) with addressing mode ZeroPageX.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 2 bytes.</remarks>
    public Mos6510Assembler STY(byte zeroPage, Mos6502RegisterX x, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STY(zeroPage, x), debugFilePath, debugLineNumber);
    /// <summary>
    /// Store Y register. STY instruction (0x8c) with addressing mode Absolute.
    /// </summary>
    /// <remarks>Cycles: 4, Size: 3 bytes.</remarks>
    public Mos6510Assembler STY(ushort address, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.STY(address), debugFilePath, debugLineNumber);
    /// <summary>
    /// Transfer A AND X to SP, store A AND X AND (high address + 1). TAS instruction (0x9b) with addressing mode AbsoluteY.
    /// </summary>
    /// <remarks>Cycles: 5, Size: 3 bytes. This is an illegal and unstable instruction.</remarks>
    [Obsolete("This instruction is unstable and may not behave as expected.", false)]
    public Mos6510Assembler TAS(ushort address, Mos6502RegisterY y, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.TAS(address, y), debugFilePath, debugLineNumber);
    /// <summary>
    /// Transfer acc to X. TAX instruction (0xaa) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler TAX([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.TAX(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Transfer acc to Y. TAY instruction (0xa8) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler TAY([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.TAY(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Transfer stack pointer to X. TSX instruction (0xba) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler TSX([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.TSX(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Transfer X to acc. TXA instruction (0x8a) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler TXA([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.TXA(), debugFilePath, debugLineNumber);
    /// <summary>
    /// . TXS instruction (0x9a) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler TXS([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.TXS(), debugFilePath, debugLineNumber);
    /// <summary>
    /// Transfer Y to acc. TYA instruction (0x98) with addressing mode Implied.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 1 byte.</remarks>
    public Mos6510Assembler TYA([CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.TYA(), debugFilePath, debugLineNumber);
    /// <summary>
    /// SBC with NOP behavior. USBC instruction (0xeb) with addressing mode Immediate.
    /// </summary>
    /// <remarks>Cycles: 2, Size: 2 bytes. This is an illegal instruction.</remarks>
    public Mos6510Assembler USBC_Imm(byte immediate, [CallerFilePath] string debugFilePath = "", [CallerLineNumber] int debugLineNumber = 0)
        => AddInstruction(Mos6510InstructionFactory.USBC_Imm(immediate), debugFilePath, debugLineNumber);
}
